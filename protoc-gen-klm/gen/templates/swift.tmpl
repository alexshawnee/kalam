// GENERATED CODE - DO NOT MODIFY
// Source: {{.FileName}}

import Foundation
import SwiftProtobuf
{{range .Services}}
{{- $svc := .}}

// ── Client ─────────────────────────────────────────────────────────────

enum {{.Name}} {
{{- range .Methods}}
{{- if .ServerStreaming}}

    static func {{.MethodName}}(_ request: {{.Input}}, onChunk: @escaping ({{.Output}}) -> Void, onEnd: @escaping (Error?) -> Void) {
        do {
            Kalam.shared.stream("{{$svc.Prefix}}{{.Name}}", try request.serializedData(),
                onChunk: { data in
                    do { onChunk(try {{.Output}}(serializedBytes: data)) }
                    catch { onEnd(error) }
                },
                onEnd: onEnd
            )
        } catch {
            onEnd(error)
        }
    }

    @available(iOS 15, macOS 12, *)
    static func {{.MethodName}}(_ request: {{.Input}}) -> AsyncThrowingStream<{{.Output}}, Error> {
        AsyncThrowingStream { continuation in
            {{$svc.Name}}.{{.MethodName}}(request,
                onChunk: { continuation.yield($0) },
                onEnd: { error in
                    if let error = error { continuation.finish(throwing: error) }
                    else { continuation.finish() }
                }
            )
        }
    }
{{- else}}

    static func {{.MethodName}}(_ request: {{.Input}}, completion: @escaping (Result<{{.Output}}, Error>) -> Void) {
        do {
            Kalam.shared.call("{{$svc.Prefix}}{{.Name}}", try request.serializedData()) { result in
                switch result {
                case .success(let data):
                    do { completion(.success(try {{.Output}}(serializedBytes: data))) }
                    catch { completion(.failure(error)) }
                case .failure(let error):
                    completion(.failure(error))
                }
            }
        } catch {
            completion(.failure(error))
        }
    }

    @available(iOS 15, macOS 12, *)
    static func {{.MethodName}}(_ request: {{.Input}}) async throws -> {{.Output}} {
        try await withCheckedThrowingContinuation { continuation in
            {{$svc.Name}}.{{.MethodName}}(request) { result in
                continuation.resume(with: result)
            }
        }
    }
{{- end}}
{{- end}}
}

// ── Server ─────────────────────────────────────────────────────────────

protocol {{.Name}}Handler {
{{- range .Methods}}
{{- if .ServerStreaming}}
    func {{.MethodName}}(_ request: {{.Input}}, onChunk: @escaping ({{.Output}}) -> Void, onEnd: @escaping () -> Void)
{{- else}}
    func {{.MethodName}}(_ request: {{.Input}}, completion: @escaping (Result<{{.Output}}, Error>) -> Void)
{{- end}}
{{- end}}
}

class {{.Name}}Router: ServiceRouter {
    private let handler: {{.Name}}Handler

    init(_ handler: {{.Name}}Handler) {
        self.handler = handler
    }

    func handle(method: String, payload: Data, sink: ResponseSink) {
        let name = method.split(separator: "/").last.map(String.init) ?? method

        switch name {
{{- range .Methods}}
{{- if .ServerStreaming}}
        case "{{.Name}}":
            do {
                let request = try {{.Input}}(serializedBytes: payload)
                handler.{{.MethodName}}(request,
                    onChunk: { response in
                        do { sink.sendChunk(try response.serializedData()) }
                        catch { sink.sendError("\(error)") }
                    },
                    onEnd: { sink.sendEnd() }
                )
            } catch {
                sink.sendError("\(error)")
            }
{{- else}}
        case "{{.Name}}":
            do {
                let request = try {{.Input}}(serializedBytes: payload)
                handler.{{.MethodName}}(request) { result in
                    switch result {
                    case .success(let response):
                        do { sink.sendUnary(try response.serializedData()) }
                        catch { sink.sendError("\(error)") }
                    case .failure(let error):
                        sink.sendError("\(error)")
                    }
                }
            } catch {
                sink.sendError("\(error)")
            }
{{- end}}
{{- end}}
        default:
            sink.sendError("Unknown method: \(method)")
        }
    }
}
{{- end}}
